---
layout: post
title: Chapter 2장 변수
date: 2022-07-17 19:20:23 +0900
category: Java
---
# Chapter 2 변수

# 1. 변수(variable)와 상수

## 1.1 변수란?

단 하나의 값을 저장할 수 있는 메모리상의 공간

## 1.2 변수의 선언과 초기화

`변수선언` 방법

```java
int age;
```

`변수타입`은 변수에 저장될 값이 어떤 타입인지를 지정하는 것

`변수이름`은 메모리 공간에 이름을 붙여주는 것

변수를 선언하면, 메모리의 빈 공간에 `변수타입`에 알맞은 크기의 저장 공간이 확보되고, 앞으로 이 저장 공간은 `변수이름`을 통해 사용할 수 있게 됨

### 변수 초기화

변수를 사용하기 전에 처음으로 값을 저장하는 것

변수를 선언한 이후 **반드시** 변수를 `초기화`해야함

이유는 알 수 없는 쓰레기값이 남아 있을 수 있기 때문

```java
// 변수 선언의 방법
// 1. 한줄씩 선언
int cnt;
int sum = 0;

// 2. CSV로 한 줄에 선언
int value, result = 0;
```

### 두 변수의 값 교환하기

두 변수를 교환하기 위해 임시 변수(temp)를 하나 만들어서 저장

```java
int x = 10;
int y = 20;
int temp = 0;

temp = x;
x = y;
y = temp;
```

## 1.3 변수의 명명규칙

`식별자`는 변수, 메서드, 클래스, 인터페이스 등등의 모든 이름

`식별자`의 규칙

1. 대소문자가 구분되며 길이에 제한이 없다.

   True와 true는 서로 다른 것으로 간주된다.

2. 예약어를 사용해서는 안된다.

   true는 예약어라서 사용할 수 없지만, True는 가능하다

3. 숫자로 시작해서는 안 된다.

   top10은 허용되지만, 7up은 허용되지 않는다.

4. 특수문자 ‘_’와 ‘$’만을 허용한다.

   $harp은 허용되지만, S#arp은 허용되지 않는다.

`예약어`(키워드 or 리져브드 위드)는 프로그래밍언어의 구문에 사용되는 언어

예약어는 `식별자` 이름으로 사용 못함

| abstract | default | if | package | this |
| --- | --- | --- | --- | --- |
| assert | do | goto | private | throw |
| boolean | double | implements | protected | throws |
| break | else | import | public | transient |
| byte | enum | instanceof | return | true |
| case | extends | int | short | try |
| catch | false | interface | static | void |
| char | final | long | strictfp | volatile |
| class | finally | native | super | while |
| const | float | new | switch |  |
| continue | for | null | synchronized |  |

권장하는 규칙

1. 클래스 이름의 첫 글자는 항상 대문자로 한다.

   변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.

2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.

   카멜케이스

3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 ‘_’로 구분한다.

   스네이크케이스

# 2. 변수의 타입

값은 `문자`와 `숫자`(정수, 실수)로 나눔

자료형은 값의 종류에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것

### 기본형과 참조형

- 기본형

   논리형, 문자형, 정수형, 실수형 계산을 위한 실제 값을 저당한다.

- 참조형

   객체의 주소를 저장한다.

참조형의 타입은 클래스를 사용

## 2.1 기본형(primitive type)

| 분류 | 타입 | 설명 |
| --- | --- | --- |
| 논리형 | boolean |  true와 false 중 하나를 값으로 갖으며, 조건이고 논리적 계산에 사용된다. |
| 문자형 | char | 문자를 저장하는데 사용되며, 변수 당 하나의 문자만 저장할 수 있다. |
| 정수형 | byte, short, int, long | 정수 값을 저장하는데 사용된다. 주로 사용되는지 것은 int와 long이다. byte는 이진 데이터를 다루는데 주로 사용되며, short은 C언어와 호환을 위해서 추가하였다. |
| 실수형 | float, double | 실수를 저장하는데 사용되며, 주로 double이 사용된다. |

`문자형`(char)는 내부적으로 정수(유니코드)로 저장하기 때문에 정수형 또는 실수형과 연산이 가능

`논리형`(boolean)은 다른 기본형과의 연산이 불가능

`정수형`은 보통 **int**, `실수형`은 **double**을 많이 사용함

각 타입의 크기

|  | 1byte | 2byte | 3byte | 4byte |
| --- | --- | --- | --- | --- |
| 논리형 | boolean |  |  |  |
| 문자형 |  | char |  |  |
| 정수형 | byte | short | int | long |
| 실수형 |  |  | float | double |

기본 자료형의 종류와 크기

- boolean은 true와 false 두 가지 값마 표현할 수 있으면 되므로 가장 작은 크기인 1byte
- char은 자바에서 유니코드(2 byte 문자체계)를 사용함으로 2 byte
- byte는 크기가 1 byte라서 byte
- int(4 byte)를 기준으로 짧아서 short(2 byte), 길어서 long(8 byte).
- float는 실수값을 부동소수점방식으로 저장하기 때문에 float
- double은 float보다 두 배의 크기(8 byte)를 갖기 때문에 double

## 2.2 상수와 리터럴(constant & literal)

`상수`는 변수와 마찬가지로 값을 저장할 수 있는 공간이지만, 변수와 달리 한번 값을 저장하면 다른 값으로 변경할 수 없음

```java
final int MAX_SPEED = 10; // 대문자와 _를 사용
```

`상수`는 **반드시 선언과 동시에 초기화**해야 하며, 그 후 부터는 상수의 값을 변경하는 것이 허용되지 않음

### 리터럴(literal)

- 변수 - 하나의 값을 저장하기 위한 공간
- 상수 - 값을 한번만 저장할 수 있는 공간
- 리터럴 - 그 자체로 값을 의미하는 것

```java
int year = 2014;
final int MAX_VALUE = 100;

// year : 변수, MAX_VALUE : 상수, 2014 : 리터럴, 100 : 리터럴
```

### 상수가 필요한 이유

```java
// 상수 사용 X
int triangleArea = (20 * 20) / 2;

// 상수 사용 o
final int WIDTH = 20;
final int HEIGHT = 10;

int triangleArea = (WIDTH * HEIGHT) / 2;
```

`상수`는 리터럴에 ‘의미있는 이름’을 붙여서 코드의 이해와 수정을 쉽게 만듦.

### 리터럴의 타입과 접미사

리터럴에도 타입이 있음.

변수의 타입은 저장된 값의 타입(리터럴의 타입)에 의해 결정

| 종류 | 리터럴 | 접미사 |
| --- | --- | --- |
| 논리형 | true, false | 없음 |
| 정수형 | 123, 0b0101, 0xFF, 100L | L |
| 실수형 | 3.14, 1.4f, 3.0e8 | f, d |
| 문자형 | 'A’, ‘1’, ‘\n’ | 없음 |
| 문자열 | “ABC”, “123” | 없음 |

`long` 타입의 리터럴에 접미사 ‘l’ 또는 ‘L’ 붙임

`정수형` 타입의 리터럴에 16진수는 접두사 ‘0x’ 또는 ‘0X’, 8진수는 ‘0’

`float` 타입의 리터럴에 접미사 ‘f’ 또는 ‘F’를 붙임

`double` 타입의 리터럴에 접미사 ‘d’ 또는 ‘D’를 붙임

`정수형`은 int 타입이 기본형

`실수형`은 double 타입이 기본형

```java
float pi = 3.14f;
float pi2 = 3.14; // 에러 float타입에 접미사 f(F)가 빠짐

double rate = 12.34d;
double rate = 12.34; // 실수형은 double이 기본형이라 d(D) 생략가능
```

리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e, 그리고 접미사 f, F, d, D를 포함하고 있으면 실수형 리터럴로 간주

| 자료형 | 리터럴 | 다른 형태의 동등한 표현 |
| --- | --- | --- |
| double | 10. | 10.0 |
| double | .10 | 0.10 |
| float | 10f | 10.0f |
| float | 3.14e3f | 3140.0f |
| double | 1e1 | 10.0 |
| double | 1e-3 | 0.001 |

### 타입의 불일치

- 넓은 타입의 변수 = 좁은 타입의 리터럴 → 가능
- 좁은 타입의 변수 = 넓은 타입의 리터럴 → 불가능

```java
int i = 'A';      // 가능
long l = 123;     // 가능
double d = 3.14f; // 가능

int ix = 0x123456789; // 불가능
float f = 3.14;       // 불가능

byte b = 65;      // 가능
short s = 0x1234; // 가능
```

### 문자 리터럴과 문자열 리터럴

작은따옴표( ’ )로 문자 **하나**를 감싼 것은 `문자 리터럴`

큰 따옴표( “ )로 문자를 감싼 것은 `문자열 리터럴`

```java
char ch = 'J';
String name = "pinguChingu";

String str = "";   // 빈 문자열 허용
char ch = '';      // 빈 문자 허용 안함
```

문자열(String)은 덧셈(+) 가능

<aside>
💡 문자열 + any type → 문자열 + 문자열 → 문자열<br>
   any type + 문자열 → 문자열 + 문자열 → 문자열

</aside>

## 2.3 형식화된 출력 - printf()

`prinf()`는 **지시자**(값을 어떻게 출력할 것인지를 지정해주는 역할)를 통해 변수의 값을 여러 가지 형식으로 변환하여 출력하는 기능을 가지고 있음

```java
System.out.printf("%d, %d, %d%n", 1, 2, 3); // %n은 줄바꿈
```

자주 사용되는 printf()의 지시자

| 지시자 | 설명 |
| --- | --- |
| %b | 불리언(boolean) |
| %d | 10진수(decimal integer) |
| %o | 8진수(octal integer) |
| %x, %X | 16진수(hexadecimal integer) |
| %f | 10진수(decimal float) |
| %e, %E | 지수형태표현(exponent) |
| %c | 문자(character) |
| %s | 문자열(string) |

지시자 `%d`앞에 ‘0’과 ‘-’를 사용하여 공간을 지정할 수 있음

```java
System.out.printf("finger=[%5d]%n", 10);  // finger=[   10]
System.out.printf("finger=[%-5d]%n", 10); // finger=[10   ]
System.out.printf("finger=[%05d]%n", 10); // finger=[00010]
```

지시자 `%x`와 `%o`에 ‘#’를 사용하면 접두사 ‘0x’와 ‘0’이 붙음

지시자 `%X`는 16진수에 사용되는 접두사와 영문자를 대문자로 출력함

```java
System.out.printf("hex=%x%n", ffffffffffffff);   // hex=ffffffffffffff
System.out.printf("hex=%#x%n", ffffffffffffff);  // hex=0xffffffffffffff
System.out.printf("hex=%#X%n", ffffffffffffff);  // hex=0XFFFFFFFFFFFFFF
```

10진수를 2진수로 출력하려면 Integer.toBinaryString(int i ); 메서드를 사용

```java
System.out.printf("binNum=%s%n", Integer.toBinaryString(ob10));
```

`%f`는 기본적으로 소수점 이하 6자리까지만 출력하므로 소수점 이하 7자리에서 **반올림**함

전체 자리수와 소수점 이하 자리를 지정할 수 있음

```java
%전체자리.소수점이하자리f

// 전체 14자리 중 소수점 10자리
System.out.printf("d=%14.10%n", 1.23456789);
```

**소수점도 한자리를 차지하며, 소수점 이하의 빈자리는 0으로 채우고 정수의 빈자리는 공백으로 채움**

지시자 %s도 공간을 지정할 수 있음

```java
System.out.printf("[%s]%n", "qwerasdfzxcv");    // 문자열의 길이만큼 출력공간 확보
System.out.printf("[%20s]%n", "qwerasdfzxcv");  // 최소 20글자 출력공간 확보(우측정렬)
System.out.printf("[%-20s]%n", "qwerasdfzxcv"); // 최소 20글자 출력공간 확보(좌측정렬)
System.out.printf("[%.8s]%n", "qwerasdfzxcv");  // 왼쪽에서 8글자만 출력
```

## 2.4 화면에서 입력받기 - Scanner

```java
import java.util.*; // util 라이브러리 추가

Scanner scan = new Scanner(System.in);  // 객체 생성
String inputValue = scan.nextLine();    // nextLine() 사용. 엔터키를 누르면 문자열로 반환
```

# 3. 진법

## 3.1 10진법과 2진법

10진수와 2진수 비교 잘하기

| 2진수 | 10진수 |
| --- | --- |
| 0 | 0 |
| 1 | 1 |
| 10 | 2 |
| 11 | 3 |
| 100 | 4 |
| 101 | 5 |
| 110 | 6 |
| 111 | 7 |
| 1000 | 8 |
| 1001 | 9 |
| 1010 | 10 |

## 3.2 비트(bit)와 바이트(byte)

`비트`(bit, binary, digit) = 한 자리의 2진수

`바이트`(byte) = 1비트 8개를 묶음

`워드`(word) = CPU가 한 번에 처리할 수 있는 데이터의 크기(4 byte)

<aside>
💡 n비트로 표현할 수 있는 10진수<br>
    값의 개수 : $2^n$<br>
    값의 범위 : 0 ~ $2^n$-1

</aside>

## 3.3 8진법과 16진법

`8진수`는 2진수 3자리를 사용. 0~7의 숫자를 기호로 사용

`16진수`는 2진수 4자리를 사용 0~F의 16개의 문자로 사용

### 2진수를 8진수, 16진수로 변환

2진수를 8진수로 변환 : 2진수를 뒤에서부터 **3자리씩** 끊어서 그에 해당하는 8진수로 바꿈

2진수를 16진수로 변환 : 2진수를 뒤에서부터 **4자리씩** 끊어서 그에 해당하는 16진수로 바꿈

| 2진수 | 8진수 | 2진수 | 8진수 |
| --- | --- | --- | --- |
| 000 | 0 | 0000 | 0 |
| 001 | 1 | 0001 | 1 |
| 010 | 2 | 0010 | 2 |
| 011 | 3 | 0011 | 3 |
| 100 | 4 | 0100 | 4 |
| 101 | 5 | 0101 | 5 |
| 110 | 6 | 0110 | 6 |
| 111 | 7 | 0111 | 7 |
|  |  | 1000 | 8 |
|  |  | 1001 | 9 |
|  |  | 1010 | A |
|  |  | 1011 | B |
|  |  | 1100 | C |
|  |  | 1101 | D |
|  |  | 1110 | E |
|  |  | 1111 | F |

## 3.4 정수의 진법 변환

### 10진수를 n진수로 변환

10진수를 다른 진수로 변환하려면, 해당 진수로 나누고 나머지 값을 옆에 적는 것을 더 이상 나눌 수 없을 때까지 반복한 다음 마지막 몫과 나머지를 아래부터 위로 순서대로 적으면 됨

![img-ch2-1.png](/public/img/posts/java/img-ch2-1.png)

### n진수를 10진수로 변환

각 자리의 수에 해당 단위의 값을 곱해서 모두 더하면 됨

![img-ch2-2.png](/public/img/posts/java/img-ch2-2.png)

## 3.5 실수의 진법변환

### 10진 소수점수를 2진 소수점수로 변환하는 방법

1. 10진 소수에 2를 곱한다.
2. 위 결과에서 소수부만 가져다가 다시 2를 곱한다.
3. 1과 2의 과정을 소수부가 0이 될 때까지 반복한다.

| 0.625 x 2 = | 1.25 |
| --- | --- |
| 0.25 x 2 = | 0.5 |
| 0.5 x 2 = | 1.0 |

위 결과에서 정수부만을 위에서 아래로 순서대로 적고 ‘0.’을 앞에 붙임

0.625 → 0.101

### 2진 소수점수를 10진 소수점수로 변환하는 방법

소수점 자리에 맞게 2의 거듭제곱(-1, -2, -3…)을 곱하면 됨

## 3.6 음수의 2진 표현 - 2의 보수법

단순히 2진수의 `왼쪽의 첫 번재 비트(MSB)`가 0이면 양수, 1이면 음수

|  | 2진수 | 부호있는 10진수 |
| --- | --- | --- |
| 1 | 0000 | 0 |
| 2 | 0001 | 1 |
| 3 | 0010 | 2 |
| 4 | 0011 | 3 |
| 5 | 0100 | 4 |
| 6 | 0101 | 5 |
| 7 | 0110 | 6 |
| 8 | 0111 | 7 |
| 9 | 1000 | -0 |
| 10 | 1001 | -1 |
| 11 | 1010 | -2 |
| 12 | 1011 | -3 |
| 13 | 1100 | -4 |
| 14 | 1101 | -5 |
| 15 | 1110 | -6 |
| 16 | 1111 | -7 |

**문제점**

- 0이 두개 존재(0, -0)
- 같은 두 수(5, -5)를 더했을 때 2진수로 0이 되지 않음
- 2진수가 증가할 때 10진 음수는 감소

### 2의 보수법

어떤 수의 ‘n의 보수’는 더했을 때 n이 되는 수

| 2진수 | 10진수(2의 보수법) |
| --- | --- |
| 0000 | 0 |
| 0001 | 1 |
| 0010 | 2 |
| 0011 | 3 |
| 0100 | 4 |
| 0101 | 5 |
| 0110 | 6 |
| 0111 | 7 |
| 1000 | -8 |
| 1001 | -7 |
| 1010 | -6 |
| 1011 | -5 |
| 1100 | -4 |
| 1101 | -3 |
| 1110 | -2 |
| 1111 | -1 |

### 2의 보수 구하기

<aside>
💡 2의 보수 = 1의 보수 + 1

</aside>

`1의 보수`는 0을 1로, 1을 1으로 바꿈

**음수의 2진 표현을 구하는 방법**

1. 음수의 절대값을 2진수로 변환한다.
2. 1에서 구한 2진수의 1을 0으로 0은 1로 바꾼다.(1의 보수 구하기)
3. 2의 결과에 1을 더한다.(2의 보수 구하기, 1의 보수 + 1)

# 4 기본형(primitive type)

## 4.1 논리형 - boolean

boolean형 변수는 true, false 값 지정 기본값은 false

```java
boolean power = true;
boolean chk = False; // 에러 대소문자 구분
```

## 4.2 문자형 - char

문자를 저장하기 위한 변수를 선언할 때 사용

```java
char ch = 'a';
```

문자의 유니코드(정수)가 저장

### 특수 문자 다루기

영문자 이외에 특수문자를 저장하는 방법

```java
char tab = '\t';
```

특수문자를 표현하는 방법

| 특수 문자 | 문자 리터럴 |
| --- | --- |
| tab | \t |
| backspace | \b |
| form feed | \f |
| new line | \n |
| carraign return | \r |
| 역슬래쉬(\) | \\ |
| 작은따옴표 | \’ |
| 큰따옴표 | \” |
| 유니코드(16진수)문자 | \u유니코드 |

### char타입의 표현형식

char타입의 크기는 2 byte

문자의 유니코드가 저장

```java
char ch = 'A';  // 저장을 할 때는 문자의 유니코드 65로 저장
short s = 65;
```

### 인코딩과 디코딩(encoding & decoding)

문자를 코드로 변환하는 것을 `문자 인코딩`

코드를 문자로 변환하는 것을 `문자 디코딩`

### 아스키(ASCII)

정보교환을 위한 미국 표준 코드

128개의 문자 집합을 제공하는 7 bit 부호

처음 32개의 문자는 인쇄와 전송 제어용(출력안됨)으로 사용되는 `제어문자`

마지막 문자(DEL)를 제외한 33번째 이후의 문자(기호, 숫자, 영대소문자) 출력가능

### 확장 아스키와 한글

아스키는 7 bit이므로 1 bit를 이용하여 문자를 추가로 정의한 것이 `확장 아스키`

`ISO 8859-1` 대표적

한글을 표현하는 것은 `확장 완성형(CP 949)` 사용

### 코드 페이지(code page, cp)

확장 아스키 이름

### 유니코드(unicode)

전 세계의 모든 문자를 하나의 통일된 문자집합으로 표현

`유니코드 문자 셋` : 유니코드에 포함시키고자 하는 문자들의 집합을 정의

`유니코드 인코딩` : 문자 셋에 번호를 붙인 것

유니코드 인코딩에는 UTF-8, UTF-6, UTF-32 등 있음 자바는 **UTF-16** 사용

## 4.3 정수형 - byte, short, int, long

자료형의 크기순

<aside>
💡 byte(1) < short(2) < int(4) < long(8)

</aside>

### 정수형의 표현형식과 범위

| 정수형의 표현형식(n 비트) | 종류 | 값의 개수 |
| --- | --- | --- |
| 0      n-1비트 | 0, 양수 | 2^(n-1)개 |
| 1      n-1비트 | 음수 | 2^(n-1)개 |

### 정수형의 선택기준

정수형 변수를 선언할 때는 int 타입으로 하고, int의 범위(약 ±20억)를 넘어서는 수를 다뤄야 할 때는 long을 사용하면 됨

### 정수형의 오버플로우

연산과정에서 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 `오버플로우`라고 함

### 부호있는 정수의 오버플로우

부호 없는 정수는 2진수로 ‘0000’이 될 때 `오버플로우`가 발생

부호 있는 정수는 부호비트가 0에서 1이 될 때 `오버플로우`가 발생

| 부호 없는 10진수 | 2진수 | 부호 있는 10진수 |
| --- | --- | --- |
| 0 | 0000 | 0 |
| 1 | 0001 | 1 |
| 2 | 0010 | 2 |
| 3 | 0011 | 3 |
| 4 | 0100 | 4 |
| 5 | 0101 | 5 |
| 6 | 0110 | 6 |
| 7 | 0111 | 7(최대값) |
| 8 | 1000 | -8(최소값) |
| 9 | 1001 | -7 |
| 10 | 1010 | -6 |
| 11 | 1011 | -5 |
| 12 | 1100 | -4 |
| 13 | 1101 | -3 |
| 14 | 1110 | -2 |
| 15(최대값) | 1111 | -1 |
| 0(최소값) | 0000 | 0 |
| 1 | 0001 | 1 |
| 2 | 0010 | 2 |

## 4.4 실수형 - float, double

### 실수형의 범위와 정밀도

실수형은 부호(S), 지수(E), 가수(M) 세 부분으로 이루어짐

실수형 타입을 선택할 때는 값의 범위뿐만 아니라 ‘정밀도’도 고려해야 한다.

<aside>
💡 실수형은 오버플로우가 발생하면 변수의 값은 무한대<br>
언더플로우는 실수형으로 표현할 수 없는 아주 작은 값, 변수의 값은 0

</aside>

### 실수형의 저장형식

실수형은 값을 부동소수점수의 형태로 저장

부동소수점수는 부호(Sign), 지수(Exponent), 가수(Mantissa) 세 부분

$± M X 10 ^{E}$

| 기호 | 의미 | 설명 |
| --- | --- | --- |
| S | 부호(Sign bit) | 1 bit. 0이면 양수, 1이면 음수 |
| E | 지수(Exponent) | 부호있는 정수. 지수의 범위는 -127~128(float), -1023~1024(double) |
| M | 가수(Mantissa) | 실제 값을 저장하는 부분. 10진수로 7자리(float), 15자리(double)의 정밀도로 저장가능 |

### 부동수서점의 오차

2진수로 유한소수라도, 가수를 저장할 수 있는 자리수가 한정되어 있으므로 저장되지 못하고 버려지는 값들이 있으면 오차가 발생

# 5. 형변환

## 5.1 형변환(캐스팅, casting)이란?

**변수 또는 상수의 타입을 다른 타입으로 변환하는 것**

## 5.2 형변환 방법

형변환하고자 하는 변수나 리터럴의 앞에 변환하고자하는 타입을 괄호와 함께 붙임

<aside>
💡 (타입)피연산자

</aside>
<br>

()는 `캐스트 연산자` 또는 `형변환 연산자`

```java
double d = 85.4;
int score = (int)d;
```

## 5.3 정수형간의 형변환

큰 타입에서 작은 타입으로의 변환

경우에 따라 `값 손실`이 발생

작은 타입에서 큰 타입으로의 변환

나머지 빈공간은 0 (양수)또는 1(음수)로 채워짐

## 5.4 실수형 간의 형변환

큰 타입에서 작은 타입으로의 변환

경우에 따라 `값 손실`이 발생

float 타입의 범위를 넘는 값을 float로 형변환하는 경우는 무한대 또는 0이 됨

```java
double d = 1.0e100;   // float의 최대값보다 큰 값을 d에 저장
float f = (float)d;   // d의 값을 float로 형변환해서 f에 저장. f의 값은 무한대

double d = 1.0e-50;   // float의 최소값보다 작은 값을 d에 저장
float f= = (float)d;  // f의 값은 0
```

작은 타입에서 큰 타입으로의 변환

나머지 빈공간은 0 (양수)또는 1(음수)로 채워짐

## 5.5 정수형과 실수형 간의 형변환

### 정수형을 실수형으로 변환

정수는 소수점 이하의 값이 없음

단순히 정수를 2진수로 변환한 다음 정규화를 거침

### 실수형을 정수형으로 변환

실수형의 소수점 이하 값은 버려짐

## 5.6 자동 형변환

서로 다른 타입간의 대입이나 연산을 할 때, 형변환으로 타입을 일치시키는 것이 원칙

경우에 다라 편의상의 이유로 형변환을 생략 가능

컴파일러가 생략된 형변환을 자동으로 추가함

```java
float f = 1234;        // 형변환의 생략

byte b = 1000;         // 에러 byte의 범위를 넘는 값을 저장

char ch = (char)1000;  // 명시적 형변환. 에러가 발생하지 않음

int i = 3;
double d = 1.0 + i;    // 형변환이 자동으로 이루어짐
```

### 자동 형변환의 규칙

<aside>
💡 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환함

</aside>
<br>
범위가 좁은 타입에서 넓은 타입으로 형변환

| 1 byte | 2 byte | 4 byte | 8 byte | 4 byte | 8 byte |
| --- | --- | --- | --- | --- | --- |
| byte | short | int | long | float | double |

1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
2. 기본형과 참조형은 서로 형변환할 수 없다.
3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.